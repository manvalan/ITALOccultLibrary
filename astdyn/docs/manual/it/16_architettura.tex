\chapter{Architettura Software}
\label{ch:architecture}

\section{Introduzione}

AstDyn è progettata come una moderna libreria C++17 per astrodinamica e determinazione orbitale. L'architettura enfatizza:

\begin{itemize}
    \item \textbf{Modularità}: Moduli indipendenti con interfacce chiare
    \item \textbf{Prestazioni}: Algoritmi numerici efficienti con Eigen3
    \item \textbf{Estensibilità}: Facile aggiungere nuovi modelli di forza, integratori, parser
    \item \textbf{Manutenibilità}: Codice pulito, test completi, documentazione
\end{itemize}

\section{Principi di Design}

\subsection{Separazione delle Responsabilità}

Ogni modulo gestisce un aspetto specifico:
\begin{itemize}
    \item \textbf{Time}: Conversioni tra scale temporali (UTC, TT, TDB)
    \item \textbf{Coordinates}: Sistemi di riferimento, trasformazioni
    \item \textbf{Orbit}: Elementi, vettori di stato, conversioni
    \item \textbf{Propagation}: Integrazione numerica, modelli di forza
    \item \textbf{Observations}: Astrometria, formato MPC, pesi
    \item \textbf{Orbit Determination}: IOD, correzione differenziale, residui
\end{itemize}

\subsection{Design Basato su Interfacce}

Interfacce astratte abilitano flessibilità:

\begin{lstlisting}[language=C++,caption={Esempi di interfacce}]
// Interfaccia parser - supporto formati multipli
class IParser {
public:
    virtual ~IParser() = default;
    virtual OrbitalElements parse(const std::string& filename) = 0;
};

// Interfaccia integratore - metodi multipli disponibili
class IIntegrator {
public:
    virtual ~IIntegrator() = default;
    virtual void integrate(State& y, double t0, double t1, ForceModel& forces) = 0;
};

// Interfaccia effemeridi - SPICE, JPL, analitico
class IEphemeris {
public:
    virtual ~IEphemeris() = default;
    virtual Vector3d get_position(Body body, double jd_tdb) = 0;
};
\end{lstlisting}

\subsection{Header-Only vs. Compilato}

\textbf{Header-only} (inline, template):
\begin{itemize}
    \item \texttt{core/Constants.hpp}: Costanti fisiche
    \item \texttt{core/Types.hpp}: Alias di tipo, enum
    \item \texttt{utils/StringUtils.hpp}: Utilità per stringhe
\end{itemize}

\textbf{Compilato} (implementazione in .cpp):
\begin{itemize}
    \item Tutti gli algoritmi numerici (propagazione, integrazione)
    \item Operazioni I/O (parsing file, caricamento osservazioni)
    \item Calcoli complessi (STM, correzione differenziale)
\end{itemize}

\section{Organizzazione dei Moduli}

\subsection{Struttura delle Directory}

\begin{lstlisting}[language=bash,caption={Layout del progetto}]
astdyn/
|-- include/astdyn/           # Header pubblici
|   |-- AstDyn.hpp           # Include principale (tutto)
|   |-- AstDynEngine.hpp     # Engine alto livello
|   |-- Version.hpp          # Info versione (generato)
|   |-- Config.hpp           # Configurazione build (generato)
|   |-- core/                # Tipi fondamentali
|   |   |-- Constants.hpp
|   |   `-- Types.hpp
|   |-- math/                # Utilita' matematiche
|   |   |-- MathUtils.hpp
|   |   `-- LinearAlgebra.hpp
|   |-- time/                # Scale temporali
|   |   `-- TimeScale.hpp
|   |-- coordinates/         # Sistemi di riferimento
|   |   |-- KeplerianElements.hpp
|   |   |-- CartesianState.hpp
|   |   `-- CometaryElements.hpp
|   |-- orbit/               # Meccanica orbitale
|   |   |-- TwoBody.hpp
|   |   `-- Perturbations.hpp
|   |-- propagation/         # Integrazione numerica
|   |   |-- Integrator.hpp
|   |   `-- Propagator.hpp
|   |-- observations/        # Dati astrometrici
|   |   |-- Observation.hpp
|   |   |-- MPCReader.hpp
|   |   `-- ObservatoryDatabase.hpp
|   |-- orbit_determination/ # Algoritmi OD
|   |   |-- GaussIOD.hpp
|   |   |-- DifferentialCorrection.hpp
|   |   |-- StateTransitionMatrix.hpp
|   |   `-- Residuals.hpp
|   |-- io/                  # Parser
|   |   |-- IParser.hpp
|   |   |-- ParserFactory.hpp
|   |   `-- parsers/
|   |       |-- OrbFitEQ1Parser.hpp
|   |       `-- OrbFitRWOParser.hpp
|   |-- ephemeris/           # Posizioni planetarie
|   |   `-- SpiceInterface.hpp
|   `-- utils/               # Utilita'
|       |-- Logger.hpp
|       `-- StringUtils.hpp
|-- src/                     # File di implementazione
|   |-- CMakeLists.txt
|   |-- AstDynEngine.cpp
|   |-- math/
|   |-- time/
|   |-- coordinates/
|   |-- orbit/
|   |-- propagation/
|   |-- observations/
|   |-- orbit_determination/
|   |-- io/
|   `-- ephemeris/
|-- tests/                   # Test unitari (Google Test)
|-- examples/                # Programmi di esempio
|-- docs/                    # Documentazione
`-- data/                    # File dati (kernel, cataloghi)
\end{lstlisting}

\subsection{Organizzazione dei Namespace}

\begin{lstlisting}[language=C++,caption={Gerarchia namespace}]
namespace astdyn {
    namespace constants {    // Costanti fisiche
        constexpr double AU = 149597870.7;  // km
        constexpr double C_LIGHT = 299792.458;  // km/s
        // ...
    }
    
    namespace math {         // Utilita' matematiche
        double mod_angle(double angle, double period);
        Matrix3d rotation_matrix_z(double angle);
        // ...
    }
    
    namespace time {         // Conversioni temporali
        double utc_to_tt(double jd_utc);
        double tt_to_tdb(double jd_tt);
        // ...
    }
    
    namespace coordinates {  // Sistemi di coordinate
        class KeplerianElements { /* ... */ };
        class CartesianState { /* ... */ };
        // ...
    }
    
    namespace observations { // Osservazioni
        class Observation { /* ... */ };
        class MPCReader { /* ... */ };
        // ...
    }
    
    // Propagazione, determinazione orbitale a livello superiore
    class Propagator { /* ... */ };
    class DifferentialCorrection { /* ... */ };
    // ...
}
\end{lstlisting}

\section{Componenti Core}

\subsection{Costanti e Tipi}

\textbf{Costanti Fisiche} (\texttt{core/Constants.hpp}):
\begin{itemize}
    \item Parametri gravitazionali: \texttt{MU\_SUN}, \texttt{MU\_EARTH}, ecc.
    \item Distanze: \texttt{AU}, \texttt{EARTH\_RADIUS}
    \item Tempo: \texttt{JD2000}, \texttt{SECONDS\_PER\_DAY}
    \item Velocità della luce, obliquità, ecc.
\end{itemize}

\textbf{Alias di Tipo} (\texttt{core/Types.hpp}):
\begin{lstlisting}[language=C++]
// Algebra lineare (Eigen)
using Vector3d = Eigen::Vector3d;
using Vector6d = Eigen::Matrix<double, 6, 1>;
using Matrix3d = Eigen::Matrix3d;
using Matrix6d = Eigen::Matrix<double, 6, 6>;

// Tipizzazione forte per unita'
using Radians = double;
using Degrees = double;
using AU_Distance = double;
using KM_Distance = double;
using JulianDate = double;
\end{lstlisting}

\textbf{Enumerazioni}:
\begin{lstlisting}[language=C++]
enum class CoordinateSystem {
    ECLIPTIC, EQUATORIAL, ICRF, BODY_FIXED
};

enum class ElementType {
    KEPLERIAN, CARTESIAN, COMETARY, EQUINOCTIAL
};

enum class TimeScale {
    UTC, UT1, TAI, TT, TDB, TCB, TCG
};

enum class IntegratorType {
    RADAU15, RK_GAUSS, DOPRI, LSODAR, GAUSS_JACKSON
};
\end{lstlisting}

\subsection{Versione e Configurazione}

\textbf{Versione} (generata da CMake):
\begin{lstlisting}[language=C++]
namespace astdyn {
    namespace Version {
        constexpr int major = 1;
        constexpr int minor = 0;
        constexpr int patch = 0;
        constexpr const char* string = "1.0.0";
    }
}
\end{lstlisting}

\textbf{Configurazione} (opzioni di build):
\begin{lstlisting}[language=C++]
namespace astdyn {
    namespace Config {
        constexpr bool use_spice = true;
        constexpr bool use_openmp = false;
        constexpr const char* build_type = "Release";
        constexpr const char* compiler = "AppleClang 16.0.0";
    }
}
\end{lstlisting}

\section{Gestione delle Dipendenze}

\subsection{Dipendenze Esterne}

\textbf{Eigen3} (richiesto):
\begin{itemize}
    \item Scopo: Algebra lineare (vettori, matrici)
    \item Versione: $\ge$ 3.3
    \item Uso: Header-only, nessun linking richiesto
    \item Motivazione: Veloce, espressivo, basato su template
\end{itemize}

\textbf{Boost} (opzionale):
\begin{itemize}
    \item Scopo: Utilità estese (filesystem, date\_time)
    \item Versione: $\ge$ 1.70
    \item Uso: Alcuni componenti compilati
    \item Motivazione: Estensioni C++ standard industriale
\end{itemize}

\textbf{SPICE} (opzionale):
\begin{itemize}
    \item Scopo: Effemeridi planetarie ad alta precisione
    \item Provider: JPL/NAIF
    \item Uso: Libreria compilata (CSPICE)
    \item Motivazione: Standard di riferimento per calcolo effemeridi
\end{itemize}

\textbf{Google Test} (solo testing):
\begin{itemize}
    \item Scopo: Framework per test unitari
    \item Versione: $\ge$ 1.10
    \item Uso: Scaricato automaticamente da CMake se non trovato
\end{itemize}

\subsection{Sistema di Build CMake}

\textbf{Funzionalità}:
\begin{itemize}
    \item CMake moderno (3.15+)
    \item Ricerca automatica dipendenze
    \item Generazione versione
    \item Opzioni di configurazione
    \item Target di installazione
    \item Export pacchetto per uso in altri progetti
\end{itemize}

\textbf{Opzioni di build}:
\begin{lstlisting}[language=bash]
cmake -B build \
  -DCMAKE_BUILD_TYPE=Release \
  -DASTDYN_BUILD_SHARED=ON \
  -DASTDYN_BUILD_TESTS=ON \
  -DASTDYN_BUILD_EXAMPLES=ON \
  -DASTDYN_USE_SPICE=ON
cmake --build build -j
cmake --install build
\end{lstlisting}

\section{Gestione degli Errori}

\subsection{Strategia}

\textbf{Eccezioni} per errori di programmazione:
\begin{lstlisting}[language=C++]
if (eccentricity < 0.0 || eccentricity >= 1.0) {
    throw std::invalid_argument("L'eccentricita' deve essere in [0, 1)");
}
\end{lstlisting}

\textbf{Optional} per fallimenti attesi:
\begin{lstlisting}[language=C++]
std::optional<Matrix3d> invert_matrix(const Matrix3d& A) {
    if (A.determinant() < 1e-15) {
        return std::nullopt;  // Singolare
    }
    return A.inverse();
}
\end{lstlisting}

\textbf{Codici di ritorno} per I/O:
\begin{lstlisting}[language=C++]
bool load_observations(const std::string& filename,
                       std::vector<Observation>& obs) {
    std::ifstream file(filename);
    if (!file) return false;
    // ...
    return true;
}
\end{lstlisting}

\subsection{Logging}

\begin{lstlisting}[language=C++]
#include <astdyn/utils/Logger.hpp>

// Livelli di gravita'
Logger::debug("Iterazione {} convergenza", iter);
Logger::info("Caricate {} osservazioni", n_obs);
Logger::warning("RMS = {:.3f} arcosecondi (alto!)", rms);
Logger::error("Caricamento kernel fallito: {}", filename);
\end{lstlisting}

\section{Gestione della Memoria}

\subsection{Ownership}

\textbf{Allocazione stack} per oggetti piccoli:
\begin{lstlisting}[language=C++]
Vector3d position;  // 24 byte
Matrix6d covariance;  // 288 byte
KeplerianElements elements;  // ~80 byte
\end{lstlisting}

\textbf{Smart pointer} per durata dinamica:
\begin{lstlisting}[language=C++]
// Ownership unico
auto propagator = std::make_unique<Propagator>(integrator, forces);

// Ownership condiviso (quando servono riferimenti multipli)
auto spice = std::make_shared<SpiceInterface>();
propagator->set_ephemeris(spice);
corrector->set_ephemeris(spice);  // Stesso oggetto
\end{lstlisting}

\textbf{Move semantics} per efficienza:
\begin{lstlisting}[language=C++]
std::vector<Observation> load_mpc_observations(const std::string& file) {
    std::vector<Observation> obs;
    // ... popola obs ...
    return obs;  // Spostato, non copiato (RVO C++11)
}
\end{lstlisting}

\subsection{Dataset Grandi}

Per grandi set di osservazioni (es. 10.000+ osservazioni):
\begin{itemize}
    \item Usare \texttt{std::vector::reserve()} per evitare riallocazioni
    \item Elaborazione stream per file troppo grandi per RAM
    \item File memory-mapped per dataset molto grandi (futuro)
\end{itemize}

\section{Threading e Parallelismo}

\subsection{Stato Attuale}

AstDyn v1.0 è single-thread. Opportunità di parallelizzazione:

\begin{enumerate}
    \item \textbf{Elaborazione osservazioni}: Calcolo partiali in parallelo
    \item \textbf{Monte Carlo}: Propagazioni orbitali multiple indipendenti
    \item \textbf{Propagazione incertezza}: Simulazioni particelle parallele
\end{enumerate}

\subsection{Piani Futuri}

\begin{lstlisting}[language=C++]
// OpenMP per parallelizzazione loop
#pragma omp parallel for
for (size_t i = 0; i < observations.size(); ++i) {
    residuals[i] = compute_residual(observations[i], state);
}

// std::async per parallelismo task
auto future1 = std::async(std::launch::async, propagate, state1, t_end);
auto future2 = std::async(std::launch::async, propagate, state2, t_end);
auto result1 = future1.get();
auto result2 = future2.get();
\end{lstlisting}

\section{Strategia di Testing}

\subsection{Test Unitari}

Framework Google Test con fixture:

\begin{lstlisting}[language=C++]
TEST(TimeScaleTest, UTCtoTT) {
    double jd_utc = 2451545.0;  // J2000.0
    double jd_tt = time::utc_to_tt(jd_utc);
    EXPECT_NEAR(jd_tt - jd_utc, 64.184 / 86400.0, 1e-10);
}

TEST(KeplerianTest, CartesianRoundTrip) {
    CartesianState cart(1.0, 0.0, 0.0, 0.0, 0.0172, 0.0);
    auto kep = KeplerianElements::from_cartesian(cart);
    auto cart2 = kep.to_cartesian();
    EXPECT_VECTOR_NEAR(cart.position, cart2.position, 1e-12);
}
\end{lstlisting}

\subsection{Test di Integrazione}

\begin{itemize}
    \item Propagazione orbite note, confronto con JPL Horizons
    \item Correzione differenziale su asteroidi reali (es. Pompeja)
    \item IOD da osservazioni sintetiche
\end{itemize}

\subsection{Benchmark Prestazionali}

\begin{lstlisting}[language=C++]
TEST(PropagationBenchmark, Pompeja60Days) {
    auto start = std::chrono::high_resolution_clock::now();
    
    propagate(initial_state, 0.0, 60.0, forces);
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "Tempo propagazione: " << duration.count() << " ms\n";
    EXPECT_LT(duration.count(), 1000);  // Deve completare in < 1 secondo
}
\end{lstlisting}

\section{Documentazione}

\subsection{Documentazione Inline}

Commenti stile Doxygen:

\begin{lstlisting}[language=C++]
/**
 * @brief Converte elementi kepleriani in stato cartesiano
 * 
 * @param elements Elementi orbitali kepleriani (a, e, i, Omega, omega, M)
 * @param mu Parametro gravitazionale [km^3/s^2]
 * @return CartesianState Posizione [km] e velocita' [km/s]
 * 
 * @note Usa soluzione iterativa equazione di Keplero per anomalia eccentrica
 * @throws std::invalid_argument se eccentricita' >= 1.0 (parabolica/iperbolica)
 */
CartesianState to_cartesian(const KeplerianElements& elements, double mu);
\end{lstlisting}

\subsection{Documentazione Esterna}

\begin{itemize}
    \item \textbf{README.md}: Avvio rapido, installazione, esempi
    \item \textbf{Questo manuale}: Teoria + implementazione
    \item \textbf{Riferimento API}: Generato da Doxygen
    \item \textbf{Esempi}: Codice funzionante commentato
\end{itemize}

\section{Riepilogo}

Caratteristiche architetturali chiave:

\begin{enumerate}
    \item \textbf{Design modulare}: Chiara separazione delle responsabilità
    \item \textbf{Basato su interfacce}: Facile estendere (parser, integratori, ecc.)
    \item \textbf{C++17 moderno}: Smart pointer, move semantics, template
    \item \textbf{Integrazione Eigen3}: Algebra lineare efficiente
    \item \textbf{Build CMake}: Multi-piattaforma, dipendenze automatiche
    \item \textbf{Testing completo}: Test unitari + test integrazione
    \item \textbf{Gestione errori chiara}: Eccezioni, optional, codici ritorno
    \item \textbf{Ben documentato}: Documentazione inline + esterna
\end{enumerate}

Il prossimo capitolo copre nel dettaglio i singoli moduli core.
