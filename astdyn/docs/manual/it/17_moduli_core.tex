\chapter{Moduli Core}
\label{ch:core_modules}

\section{Introduzione}

Questo capitolo documenta i moduli core che implementano gli algoritmi di meccanica orbitale. Ogni modulo è progettato per essere indipendente ma componibile.

\section{Elementi Orbitali}

\subsection{KeplerianElements}

Sei elementi kepleriani classici per orbite ellittiche.

\begin{lstlisting}[language=C++,caption={Classe KeplerianElements}]
namespace astdyn {
namespace coordinates {

class KeplerianElements {
public:
    // Elementi
    double a;      // Semiasse maggiore [AU]
    double e;      // Eccentricita' [0, 1)
    double i;      // Inclinazione [rad]
    double Omega;  // Longitudine nodo ascendente [rad]
    double omega;  // Argomento perielio [rad]
    double M;      // Anomalia media [rad]
    
    // Epoca
    double epoch;  // Data giuliana [TDB]
    
    // Costruzione
    KeplerianElements() = default;
    KeplerianElements(double a, double e, double i,
                     double Omega, double omega, double M,
                     double epoch);
    
    // Conversioni
    static KeplerianElements from_cartesian(
        const Vector6d& state, double epoch, double mu = MU_SUN);
    
    Vector6d to_cartesian(double mu = MU_SUN) const;
    
    // Quantita' derivate
    double period() const;           // Periodo orbitale [giorni]
    double mean_motion() const;      // Moto medio [rad/giorno]
    double perihelion_distance() const;  // q [AU]
    double aphelion_distance() const;    // Q [AU]
    double orbital_energy(double mu = MU_SUN) const;
    
    // Anomalia media a epoca diversa
    double mean_anomaly_at(double jd) const;
    
    // Validazione
    bool is_valid() const;
};

}} // namespace
\end{lstlisting}

\textbf{Uso}:
\begin{lstlisting}[language=C++]
using namespace astdyn::coordinates;

// Crea da elementi
KeplerianElements elem;
elem.a = 2.77;          // AU
elem.e = 0.075;
elem.i = 10.6 * DEG_TO_RAD;
elem.Omega = 80.3 * DEG_TO_RAD;
elem.omega = 73.6 * DEG_TO_RAD;
elem.M = 0.0;
elem.epoch = 2460000.5;

// Quantita' derivate
std::cout << "Periodo: " << elem.period() << " giorni\n";
std::cout << "q: " << elem.perihelion_distance() << " AU\n";

// Converti in cartesiano
Vector6d state = elem.to_cartesian();
\end{lstlisting}

\subsection{CometaryElements}

Ottimizzato per orbite paraboliche e quasi-paraboliche (comete).

\begin{lstlisting}[language=C++]
class CometaryElements {
public:
    double q;      // Distanza perielio [AU]
    double e;      // Eccentricita'
    double i;      // Inclinazione [rad]
    double Omega;  // Longitudine nodo ascendente [rad]
    double omega;  // Argomento perielio [rad]
    double T;      // Tempo passaggio perielio [JD]
    double epoch;
    
    Vector6d to_cartesian(double jd, double mu = MU_SUN) const;
    static CometaryElements from_keplerian(const KeplerianElements& kep);
};
\end{lstlisting}

\subsection{CartesianState}

Vettori posizione e velocità.

\begin{lstlisting}[language=C++]
struct CartesianState {
    Vector3d position;  // [AU]
    Vector3d velocity;  // [AU/giorno]
    double epoch;       // [JD TDB]
    
    Vector6d as_vector() const {
        Vector6d v;
        v << position, velocity;
        return v;
    }
    
    double distance() const { return position.norm(); }
    double speed() const { return velocity.norm(); }
};
\end{lstlisting}

\section{Modelli di Forza}

\subsection{Interfaccia ForceModel}

\begin{lstlisting}[language=C++]
class ForceModel {
public:
    virtual ~ForceModel() = default;
    
    // Calcola accelerazione [AU/giorno^2]
    virtual Vector3d acceleration(
        const Vector6d& state,
        double jd_tdb) const = 0;
    
    // Derivate parziali per STM (opzionale)
    virtual Matrix3d acceleration_partials_position(
        const Vector6d& state,
        double jd_tdb) const {
        return Matrix3d::Zero();
    }
    
    virtual Matrix3d acceleration_partials_velocity(
        const Vector6d& state,
        double jd_tdb) const {
        return Matrix3d::Zero();
    }
};
\end{lstlisting}

\subsection{Gravità a Massa Puntiforme}

\begin{lstlisting}[language=C++]
class PointMassGravity : public ForceModel {
private:
    std::shared_ptr<IEphemeris> ephemeris_;
    std::vector<Body> bodies_;  // Sole, pianeti
    
public:
    PointMassGravity(std::shared_ptr<IEphemeris> eph,
                     const std::vector<Body>& bodies)
        : ephemeris_(eph), bodies_(bodies) {}
    
    Vector3d acceleration(const Vector6d& state, double jd) const override {
        Vector3d r_obj = state.head<3>();
        Vector3d acc = Vector3d::Zero();
        
        for (Body body : bodies_) {
            Vector3d r_body = ephemeris_->get_position(body, jd);
            Vector3d d = r_body - r_obj;
            double d_norm = d.norm();
            
            // Termine diretto
            acc += body.mu * d / (d_norm * d_norm * d_norm);
            
            // Termine indiretto (se non e' il Sole)
            if (body != Body::SUN) {
                double r_norm = r_body.norm();
                acc -= body.mu * r_body / (r_norm * r_norm * r_norm);
            }
        }
        
        return acc;
    }
};
\end{lstlisting}

\subsection{Modello di Forza Combinato}

\begin{lstlisting}[language=C++]
class CombinedForceModel : public ForceModel {
private:
    std::vector<std::shared_ptr<ForceModel>> models_;
    
public:
    void add_model(std::shared_ptr<ForceModel> model) {
        models_.push_back(model);
    }
    
    Vector3d acceleration(const Vector6d& state, double jd) const override {
        Vector3d acc = Vector3d::Zero();
        for (const auto& model : models_) {
            acc += model->acceleration(state, jd);
        }
        return acc;
    }
};
\end{lstlisting}

\section{Integrazione Numerica}

\subsection{Interfaccia Integrator}

\begin{lstlisting}[language=C++]
class IIntegrator {
public:
    virtual ~IIntegrator() = default;
    
    // Passo singolo
    virtual void step(Vector6d& y, double& t, double dt,
                     const ForceModel& forces) = 0;
    
    // Integra da t0 a t1
    virtual void integrate(Vector6d& y, double t0, double t1,
                          const ForceModel& forces,
                          double dt_initial = 0.01) = 0;
    
    // Ottieni statistiche
    virtual size_t num_steps() const = 0;
    virtual size_t num_function_calls() const = 0;
};
\end{lstlisting}

\subsection{Runge-Kutta-Fehlberg 7(8)}

Dimensione passo adattiva, alta accuratezza.

\begin{lstlisting}[language=C++]
class RKF78 : public IIntegrator {
private:
    double tol_;         // Tolleranza errore
    double dt_min_;      // Dimensione passo minima
    double dt_max_;      // Dimensione passo massima
    size_t n_steps_;
    size_t n_fcalls_;
    
public:
    RKF78(double tol = 1e-12,
          double dt_min = 1e-6,
          double dt_max = 100.0)
        : tol_(tol), dt_min_(dt_min), dt_max_(dt_max),
          n_steps_(0), n_fcalls_(0) {}
    
    void integrate(Vector6d& y, double t0, double t1,
                  const ForceModel& forces,
                  double dt) override {
        double t = t0;
        double h = dt;
        
        while (t < t1) {
            if (t + h > t1) h = t1 - t;
            
            // Coefficienti e stadi RKF78 (13 stadi)
            Vector6d k[13];
            // ... calcola stadi ...
            
            // Soluzioni 7° e 8° ordine
            Vector6d y7 = y + h * (/* combinazione 7° ordine */);
            Vector6d y8 = y + h * (/* combinazione 8° ordine */);
            
            // Stima errore
            double err = (y8 - y7).norm();
            
            // Accetta/rifiuta e adatta passo
            if (err < tol_) {
                y = y8;
                t += h;
                n_steps_++;
            }
            
            // Aggiorna dimensione passo
            h *= 0.9 * std::pow(tol_ / err, 1.0/8.0);
            h = std::clamp(h, dt_min_, dt_max_);
            
            n_fcalls_ += 13;
        }
    }
};
\end{lstlisting}

\section{Propagazione Orbitale}

\subsection{Classe Propagator}

Interfaccia alto livello che combina integratore e forze.

\begin{lstlisting}[language=C++]
class Propagator {
private:
    std::shared_ptr<IIntegrator> integrator_;
    std::shared_ptr<ForceModel> forces_;
    std::shared_ptr<IEphemeris> ephemeris_;
    
public:
    Propagator(std::shared_ptr<IIntegrator> integ,
               std::shared_ptr<ForceModel> forces,
               std::shared_ptr<IEphemeris> eph)
        : integrator_(integ), forces_(forces), ephemeris_(eph) {}
    
    // Propaga stato
    Vector6d propagate(const Vector6d& y0, double t0, double t1) {
        Vector6d y = y0;
        integrator_->integrate(y, t0, t1, *forces_);
        return y;
    }
    
    // Propaga con STM
    std::pair<Vector6d, Matrix6d> propagate_with_stm(
        const Vector6d& y0, double t0, double t1) {
        
        // Stato aumentato: [y, Phi(vettorizzata)]
        VectorXd aug(42);  // 6 + 36
        aug.head<6>() = y0;
        aug.tail<36>() = Matrix6d::Identity().reshaped();
        
        // Integra equazioni variazionali
        integrator_->integrate(aug, t0, t1, *forces_);
        
        Vector6d y = aug.head<6>();
        Matrix6d Phi = Map<Matrix6d>(aug.tail<36>().data());
        
        return {y, Phi};
    }
    
    // Genera tabella effemeridi
    std::vector<std::pair<double, Vector6d>> 
    generate_ephemeris(const Vector6d& y0, double t0,
                      double t1, double dt) {
        std::vector<std::pair<double, Vector6d>> table;
        Vector6d y = y0;
        double t = t0;
        
        while (t <= t1) {
            table.emplace_back(t, y);
            if (t + dt > t1) dt = t1 - t;
            integrator_->integrate(y, t, t + dt, *forces_);
            t += dt;
        }
        
        return table;
    }
};
\end{lstlisting}

\textbf{Esempio d'uso}:
\begin{lstlisting}[language=C++]
// Configurazione
auto spice = std::make_shared<SpiceInterface>();
spice->load_kernel("de440.bsp");

auto forces = std::make_shared<PointMassGravity>(
    spice, {Body::SUN, Body::JUPITER, Body::SATURN});

auto integrator = std::make_shared<RKF78>(1e-12);

Propagator prop(integrator, forces, spice);

// Propaga Pompeja per 60 giorni
Vector6d y0 = /* stato iniziale */;
double t0 = 2460000.5;
double t1 = t0 + 60.0;

Vector6d y_final = prop.propagate(y0, t0, t1);

std::cout << "Posizione finale: " << y_final.head<3>().transpose() << " AU\n";
\end{lstlisting}

\section{Osservazioni}

\subsection{Classe Observation}

\begin{lstlisting}[language=C++]
namespace astdyn {
namespace observations {

struct Observation {
    double epoch;        // JD UTC
    double ra;           // Ascensione retta [rad]
    double dec;          // Declinazione [rad]
    double sigma_ra;     // Incertezza RA [rad]
    double sigma_dec;    // Incertezza Dec [rad]
    std::string obs_code; // Codice osservatorio MPC
    double magnitude;    // Magnitudine apparente
    
    // Calcolata da RA/Dec
    Vector3d line_of_sight() const {
        return Vector3d(
            std::cos(dec) * std::cos(ra),
            std::cos(dec) * std::sin(ra),
            std::sin(dec)
        );
    }
    
    // Peso per minimi quadrati
    double weight_ra() const { return 1.0 / (sigma_ra * sigma_ra); }
    double weight_dec() const { return 1.0 / (sigma_dec * sigma_dec); }
};

}} // namespace
\end{lstlisting}

\subsection{MPC Reader}

Parsing formato 80 colonne del Minor Planet Center.

\begin{lstlisting}[language=C++]
class MPCReader {
public:
    static std::vector<Observation> read_file(const std::string& filename) {
        std::vector<Observation> obs;
        std::ifstream file(filename);
        std::string line;
        
        while (std::getline(file, line)) {
            if (line.length() < 80) continue;
            if (line[14] == 'S' || line[14] == 'X') continue; // Satellite/roving
            
            Observation ob;
            
            // Parsing colonne (specifica formato MPC)
            ob.obs_code = line.substr(77, 3);
            
            // Data/ora
            int year = std::stoi(line.substr(15, 4));
            int month = std::stoi(line.substr(20, 2));
            double day = std::stod(line.substr(23, 8));
            ob.epoch = date_to_jd(year, month, day);
            
            // RA: HH MM SS.sss
            int ra_h = std::stoi(line.substr(32, 2));
            int ra_m = std::stoi(line.substr(35, 2));
            double ra_s = std::stod(line.substr(38, 5));
            ob.ra = (ra_h + ra_m/60.0 + ra_s/3600.0) * 15.0 * DEG_TO_RAD;
            
            // Dec: +DD MM SS.ss
            char sign = line[44];
            int dec_d = std::stoi(line.substr(45, 2));
            int dec_m = std::stoi(line.substr(48, 2));
            double dec_s = std::stod(line.substr(51, 4));
            ob.dec = (dec_d + dec_m/60.0 + dec_s/3600.0) * DEG_TO_RAD;
            if (sign == '-') ob.dec = -ob.dec;
            
            // Magnitudine
            if (line.length() >= 70 && line[65] != ' ') {
                ob.magnitude = std::stod(line.substr(65, 5));
            }
            
            // Incertezze predefinite (dipendenti da catalogo)
            ob.sigma_ra = 0.5 * ARCSEC_TO_RAD;
            ob.sigma_dec = 0.5 * ARCSEC_TO_RAD;
            
            obs.push_back(ob);
        }
        
        return obs;
    }
};
\end{lstlisting}

\section{Database Osservatori}

\subsection{ObservatoryCoordinates}

\begin{lstlisting}[language=C++]
struct ObservatoryCoordinates {
    std::string code;
    double longitude;  // [rad] Est positivo
    double latitude;   // [rad] geocentrico
    double altitude;   // [m] sopra livello mare
    
    // Posizione geocentrica a tempo dato
    Vector3d position_itrf(double jd_utc) const {
        // Ellissoide WGS84
        const double a = 6378137.0;  // m
        const double f = 1.0 / 298.257223563;
        const double e2 = 2*f - f*f;
        
        double N = a / std::sqrt(1 - e2 * std::sin(latitude) * std::sin(latitude));
        
        double x = (N + altitude) * std::cos(latitude) * std::cos(longitude);
        double y = (N + altitude) * std::cos(latitude) * std::sin(longitude);
        double z = (N * (1 - e2) + altitude) * std::sin(latitude);
        
        return Vector3d(x, y, z) / 1000.0;  // Converti in km
    }
    
    // Ruota a sistema inerziale
    Vector3d position_icrf(double jd_utc) const {
        Vector3d r_itrf = position_itrf(jd_utc);
        Matrix3d R = earth_rotation_matrix(jd_utc);  // ITRF -> ICRF
        return R * r_itrf / AU;  // Converti in AU
    }
};
\end{lstlisting}

\section{Riepilogo}

I moduli core forniscono:

\begin{enumerate}
    \item \textbf{Elementi Orbitali}: Rappresentazioni kepleriane, cartesiane, cometarie
    \item \textbf{Modelli di Forza}: Interfaccia estensibile per perturbazioni
    \item \textbf{Integratori}: Metodi RK con dimensione passo adattiva
    \item \textbf{Propagator}: Propagazione orbitale alto livello con STM
    \item \textbf{Osservazioni}: Misure astrometriche e parsing MPC
    \item \textbf{Osservatori}: Coordinate geodetiche e trasformazioni
\end{enumerate}

Tutti i moduli sono progettati per composizione ed estensibilità.
