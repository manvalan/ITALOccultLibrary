\chapter{Sviluppi Futuri}
\label{ch:future}

\section{Introduzione}

Questo capitolo delinea i miglioramenti pianificati e le direzioni di ricerca future per AstDyn. Sebbene l'attuale release v1.0 fornisca capacità di determinazione orbitale di livello produttivo, diverse estensioni potrebbero ampliare funzionalità e prestazioni.

\section{Forze Non Gravitazionali}

\subsection{Pressione di Radiazione Solare}

\textbf{Stato}: Implementazione parziale esistente (esempio nel Capitolo 20).

\textbf{Pianificato}:
\begin{itemize}
    \item Integrazione completa nel framework dei modelli di forza
    \item Modello di ombreggiamento (occultazione Terra/Luna)
    \item Ri-irradiazione termica (effetto Yarkovsky)
    \item Stima dei parametri nella correzione differenziale
\end{itemize}

\textbf{Schema di implementazione}:
\begin{lstlisting}[language=C++]
class SolarRadiationPressure : public ForceModel {
public:
    SolarRadiationPressure(
        double area_mass_ratio,
        double reflectivity = 1.0,
        bool include_yarkovsky = false
    );
    
    Vector3d acceleration(double t, const Vector3d& pos, 
                         const Vector3d& vel) const override;
    
    // Per correzione differenziale
    bool supports_partials() const override { return true; }
    std::pair<Matrix3d, Matrix3d> partials(...) const override;
    
private:
    double area_mass_ratio_;
    double reflectivity_;
    bool include_yarkovsky_;
    
    // Calcolo dell'ombra
    double shadow_function(double t, const Vector3d& pos) const;
};
\end{lstlisting}

\textbf{Impatto scientifico}: Critico per piccoli NEA e tracciamento detriti spaziali.

\subsection{Degassamento Cometario}

\textbf{Motivazione}: Le comete esibiscono accelerazioni non gravitazionali dovute alla sublimazione di volatili.

\textbf{Modello pianificato}:
\begin{itemize}
    \item Formulazione di Marsden: termini $A_1/r^2 + A_2/r^3 + A_3$
    \item Componenti radiale, trasversale e normale
    \item Curva di attività dipendente dalla temperatura
\end{itemize}

\begin{lstlisting}[language=C++]
class CometaryOutgassing : public ForceModel {
public:
    CometaryOutgassing(double A1, double A2, double A3);
    
    Vector3d acceleration(double t, const Vector3d& pos, 
                         const Vector3d& vel) const override {
        Vector3d r_sun = pos;  // Posizione eliocentrica
        double r = r_sun.norm();
        
        // Modello di Marsden
        Vector3d radial = r_sun.normalized();
        Vector3d transverse = /* calcola dalla velocita' */;
        Vector3d normal = radial.cross(transverse);
        
        double g = activity_function(r);  // Curva di attivita'
        
        return g * (A1_ * radial + A2_ * transverse + A3_ * normal) / (r * r);
    }
    
private:
    double A1_, A2_, A3_;
    double activity_function(double r) const;
};
\end{lstlisting}

\textbf{Caso d'uso}: Comete a lungo periodo, comete a breve periodo con degassamento significativo.

\subsection{Relatività Generale}

\textbf{Limitazione attuale}: Effetti post-newtoniani trascurati.

\textbf{Pianificato}: Correzioni relativistiche del primo ordine.

\textbf{Formulazione}:
\[
\mathbf{a}_{\text{rel}} = \frac{GM_\odot}{c^2 r^3} \left[ 4 \frac{GM_\odot}{r} - v^2 \right] \mathbf{r} + 4 \frac{GM_\odot}{c^2 r^3} (\mathbf{r} \cdot \mathbf{v}) \mathbf{v}
\]

\textbf{Implementazione}:
\begin{lstlisting}[language=C++]
class RelativisticCorrection : public ForceModel {
public:
    Vector3d acceleration(double t, const Vector3d& pos, 
                         const Vector3d& vel) const override {
        double r = pos.norm();
        double v2 = vel.squaredNorm();
        double rdotv = pos.dot(vel);
        
        double factor1 = 4.0 * GM_SUN / r - v2;
        double factor2 = 4.0 * rdotv;
        
        return (GM_SUN / (C * C * r * r * r)) * 
               (factor1 * pos + factor2 * vel);
    }
};
\end{lstlisting}

\textbf{Magnitudine}: $\sim 10^{-8}$ m/s$^2$ a 1 AU—influenza significativamente Mercurio, trascurabile per asteroidi oltre Marte.

\section{Propagazione delle Incertezze}

\subsection{Propagazione della Covarianza}

\textbf{Attuale}: STM singola per iterazione.

\textbf{Pianificato}: Propagazione completa della matrice di covarianza con rumore di processo.

\begin{lstlisting}[language=C++]
class CovariancePropagator {
public:
    struct Result {
        CartesianState mean_state;
        Matrix6d covariance;
    };
    
    Result propagate_with_covariance(
        const CartesianState& initial_state,
        const Matrix6d& initial_covariance,
        double target_epoch,
        const Matrix6d& process_noise
    );
};
\end{lstlisting}

\textbf{Applicazione}: Previsione dell'incertezza, probabilità di collisione.

\subsection{Metodi Monte Carlo}

\textbf{Motivazione}: Propagazione non lineare dell'incertezza.

\textbf{Pianificato}:
\begin{lstlisting}[language=C++]
class MonteCarloUncertainty {
public:
    struct Sample {
        orbit::KeplerianElements elements;
        double weight;
    };
    
    std::vector<Sample> generate_samples(
        const orbit::KeplerianElements& nominal,
        const Matrix6d& covariance,
        size_t n_samples = 10000
    );
    
    std::vector<CartesianState> propagate_ensemble(
        const std::vector<Sample>& samples,
        double target_epoch
    );
    
    // Riepilogo statistico
    struct Statistics {
        CartesianState mean;
        CartesianState median;
        Matrix6d covariance;
        double position_rms;
    };
    
    Statistics compute_statistics(
        const std::vector<CartesianState>& ensemble
    );
};
\end{lstlisting}

\textbf{Caso d'uso}: Evitamento collisioni, analisi di avvicinamenti ravvicinati.

\section{Gestione degli Incontri Ravvicinati}

\subsection{Tecniche di Regolarizzazione}

\textbf{Problema}: Gli integratori standard hanno difficoltà con gli incontri planetari ravvicinati ($< 0.1$ AU).

\textbf{Pianificato}: Regolarizzazione di Kustaanheimo-Stiefel (KS) per rimozione delle singolarità.

\textbf{Trasformazione KS}:
\[
\mathbf{r} = \mathbf{u}^T L \mathbf{u}, \quad d\tau = r \, dt
\]

Trasforma il problema dei due corpi singolare in un oscillatore armonico regolare.

\textbf{Schema di implementazione}:
\begin{lstlisting}[language=C++]
class KSRegularizedIntegrator : public IIntegrator {
public:
    void integrate(double t0, double tf, std::vector<double>& y,
                  const std::function<...>& derivs) override {
        // Rileva avvicinamento ravvicinato
        if (is_close_approach(y)) {
            // Passa a coordinate KS
            auto u = cartesian_to_ks(y);
            // Integra nello spazio regolarizzato
            integrate_ks(t0, tf, u);
            // Trasforma indietro
            y = ks_to_cartesian(u);
        } else {
            // Integrazione standard
            standard_integrate(t0, tf, y, derivs);
        }
    }
};
\end{lstlisting}

\textbf{Beneficio}: Integrazione stabile attraverso sorvoli planetari.

\subsection{Analisi di Incontri Iperbolici}

\textbf{Funzionalità pianificate}:
\begin{itemize}
    \item Rilevamento automatico di incontri ravvicinati
    \item Parametri di targeting del piano B
    \item Calcolo della velocità e geometria dell'incontro
    \item Previsione degli elementi orbitali post-incontro
\end{itemize}

\section{Elaborazione Parallela}

\subsection{Parallelizzazione OpenMP}

\textbf{Limitazione attuale}: Solo single-thread.

\textbf{Operazioni target}:
\begin{enumerate}
    \item Propagazione batch di orbite
    \item Calcolo dei residui delle osservazioni
    \item Campionamento Monte Carlo
    \item Ricerca su griglia di parametri
\end{enumerate}

\textbf{Implementazione}:
\begin{lstlisting}[language=C++]
// Propagazione batch parallela
#pragma omp parallel for schedule(dynamic)
for (int i = 0; i < n_orbits; ++i) {
    auto state = propagator.propagate(initial_states[i], target_epoch);
    results[i] = state;
}

// Calcolo parallelo dei residui nella correzione differenziale
#pragma omp parallel for
for (int i = 0; i < n_observations; ++i) {
    auto computed = compute_predicted_observation(obs[i]);
    residuals[2*i] = obs[i].ra - computed.ra;
    residuals[2*i+1] = obs[i].dec - computed.dec;
}
\end{lstlisting}

\textbf{Speedup atteso}: 6-7$\times$ su CPU 8-core per operazioni batch.

\subsection{Accelerazione GPU}

\textbf{Obiettivo a lungo termine}: CUDA/OpenCL per parallelismo massiccio.

\textbf{Attività adatte}:
\begin{itemize}
    \item Incertezza Monte Carlo (10.000+ campioni)
    \item Generazione di tabelle di effemeridi
    \item Risoluzione batch di minimi quadrati
\end{itemize}

\textbf{Sfida}: Adattività della dimensione del passo di integrazione difficile su GPU.

\section{Integratori Aggiuntivi}

\subsection{Integratori Simplettici}

\textbf{Motivazione}: Conservazione dell'energia per studi di stabilità a lungo termine.

\textbf{Pianificato}: Mappa simplettica di Wisdom-Holman per sistemi gerarchici.

\begin{lstlisting}[language=C++]
class SymplecticIntegrator : public IIntegrator {
public:
    SymplecticIntegrator(double fixed_step_size);
    
    // Splitting dell'operatore: H = H_Kepler + H_interaction
    void step(double t, std::vector<double>& y, ...) override;
    
private:
    void drift_step(std::vector<double>& y, double dt);
    void kick_step(std::vector<double>& y, double dt);
};
\end{lstlisting}

\textbf{Caso d'uso}: Dinamica asteroidale su milioni di anni, stabilità di sistemi planetari.

\subsection{Metodi Impliciti}

\textbf{Pianificato}: Radau IIA per problemi rigidi (stiff).

\textbf{Vantaggio}: Stabilità incondizionata, buono per sistemi strettamente legati.

\textbf{Svantaggio}: Richiede calcolo dello Jacobiano, più lento per passo.

\section{Binding Python}

\subsection{Interfaccia pybind11}

\textbf{Obiettivo}: Accesso Python senza soluzione di continuità ad AstDyn.

\textbf{API pianificata}:
\begin{lstlisting}[language=Python]
import astdyn

# Crea elementi orbitali
elem = astdyn.KeplerianElements(
    a=2.7436, e=0.0624, i=11.74,
    Omega=339.86, omega=258.03, M=45.32,
    epoch=2460000.5
)

# Configura propagatore
eph = astdyn.SPICEEphemeris("de440.bsp")
forces = astdyn.PointMassGravity(eph, ["JUPITER", "SATURN"])
integrator = astdyn.RKF78(tolerance=1e-12)
prop = astdyn.Propagator(integrator, forces, eph)

# Propaga
state0 = elem.to_cartesian()
state60 = prop.propagate(state0, 2460060.5)

print(f"Posizione: {state60.position}")
print(f"Velocita': {state60.velocity}")

# Determinazione orbitale
observations = astdyn.read_mpc_file("observations.txt")
corrector = astdyn.DifferentialCorrector(prop)
result = corrector.solve(elem, observations)

print(f"Residuo RMS: {result.rms_residual} arcosecondi")
print(f"Convergenza: {result.converged}")
\end{lstlisting}

\textbf{Integrazione}: Notebook Jupyter, array NumPy, grafici matplotlib.

\subsection{Distribuzione del Pacchetto}

\textbf{Pianificato}:
\begin{itemize}
    \item Pacchetto PyPI: \texttt{pip install astdyn}
    \item Pacchetto Conda: \texttt{conda install -c conda-forge astdyn}
    \item Wheel pre-compilate per Linux, macOS, Windows
\end{itemize}

\section{Integrazione con Machine Learning}

\subsection{Modelli Surrogati con Reti Neurali}

\textbf{Direzione di ricerca}: Addestrare reti neurali per approssimare calcoli costosi.

\textbf{Applicazioni potenziali}:
\begin{enumerate}
    \item \textbf{Propagazione veloce}: NN approssima l'integratore per applicazioni in tempo reale
    \item \textbf{Rilevamento outlier}: ML identifica automaticamente osservazioni errate
    \item \textbf{Orbita iniziale}: NN fornisce una migliore stima IOD da osservazioni limitate
\end{enumerate}

\textbf{Concetto preliminare}:
\begin{lstlisting}[language=C++]
class NeuralPropagator : public IIntegrator {
public:
    NeuralPropagator(const std::string& model_file);
    
    // Usa NN per propagazione a breve termine
    CartesianState propagate(const CartesianState& initial, 
                            double dt) {
        if (dt < 10.0) {  // Usa NN per archi brevi
            return nn_predict(initial, dt);
        } else {  // Fallback a integrazione numerica
            return numerical_propagate(initial, dt);
        }
    }
    
private:
    NeuralNetwork model_;
};
\end{lstlisting}

\textbf{Sfida}: Garantire garanzie di accuratezza per uso scientifico.

\section{Osservazioni Avanzate}

\subsection{Osservazioni Radar}

\textbf{Pianificato}: Supporto per misure di distanza e velocità radiale.

\begin{lstlisting}[language=C++]
struct RadarObservation {
    double epoch;
    double range;           // km
    double range_rate;      // km/s
    double sigma_range;
    double sigma_range_rate;
    std::string station_code;
    
    Vector3d observer_position() const;
};
\end{lstlisting}

\textbf{Integrazione}: Aggiungi residui radar ai minimi quadrati:
\[
\chi^2 = \sum_i \frac{(\rho_i^{\text{obs}} - \rho_i^{\text{comp}})^2}{\sigma_{\rho,i}^2} + \frac{(\dot{\rho}_i^{\text{obs}} - \dot{\rho}_i^{\text{comp}})^2}{\sigma_{\dot{\rho},i}^2}
\]

\textbf{Beneficio}: Accuratezza in distanza di ordini di grandezza superiore rispetto all'ottico.

\subsection{Astrometria Gaia}

\textbf{Pianificato}: Supporto nativo per osservazioni del satellite Gaia.

\textbf{Funzionalità}:
\begin{itemize}
    \item Misure along-scan e across-scan
    \item Sistema di riferimento Gaia (ICRF3)
    \item Correzioni di parallasse
    \item Tempo luce e aberrazione a livello di $\mu$as
\end{itemize}

\section{Servizio Web / Deployment Cloud}

\subsection{API RESTful}

\textbf{Visione}: Servizio di determinazione orbitale basato su cloud.

\textbf{Endpoint pianificati}:
\begin{verbatim}
POST /api/v1/propagate
  Body: { "elements": {...}, "target_epoch": 2460100.5 }
  Returns: { "state": {...}, "elapsed_ms": 1.82 }

POST /api/v1/orbit_determination
  Body: { "observations": [...], "method": "differential_correction" }
  Returns: { "elements": {...}, "rms": 0.658, "iterations": 4 }

GET /api/v1/ephemeris?object=pompeja&start=2460000&end=2460100&step=1
  Returns: [ { "epoch": 2460000.5, "position": [...], ...}, ... ]
\end{verbatim}

\textbf{Stack tecnologico}:
\begin{itemize}
    \item Backend: Servizio C++ con wrapper REST
    \item Coda: Redis per gestione job
    \item Database: PostgreSQL per archiviazione risultati
    \item Container: Deployment Docker
\end{itemize}

\subsection{Interfaccia Web}

\textbf{Funzionalità}:
\begin{itemize}
    \item Caricamento file osservazioni MPC
    \item Visualizzazione interattiva orbita (3D)
    \item Download risultati (CSV, JSON, formato OrbFit)
    \item Confronto con JPL Horizons
    \item Interfaccia elaborazione batch
\end{itemize}

\section{Integrazione Pipeline Dati}

\subsection{Elaborazione Automatizzata di Survey}

\textbf{Obiettivo}: Processare automaticamente flussi dati LSST/Pan-STARRS.

\textbf{Pipeline}:
\begin{enumerate}
    \item Ingestione: Ricezione nuove osservazioni da survey
    \item Matching: Collegamento a oggetti noti o rilevamento di nuovi
    \item IOD: Orbita rapida per nuove rilevazioni
    \item Raffinamento: Correzione differenziale con dati d'archivio
    \item Pubblicazione: Aggiornamento database elementi orbitali
    \item Allerta: Segnalazione oggetti interessanti (NEA, orbite inusuali)
\end{enumerate}

\textbf{Scalabilità}: Elaborazione di oltre 1000 oggetti per notte.

\section{Modelli di Errore Migliorati}

\subsection{Stima Robusta}

\textbf{Attuale}: Minimi quadrati assume errori gaussiani.

\textbf{Pianificato}: Perdita di Huber e minimi quadrati ripesati iterativamente.

\begin{lstlisting}[language=C++]
class RobustDifferentialCorrector : public DifferentialCorrector {
public:
    Result solve(...) override {
        // Minimi quadrati iniziali
        auto result = standard_solve(...);
        
        // Iterazione robusta
        for (int iter = 0; iter < max_robust_iters; ++iter) {
            // Calcola pesi basati sui residui
            update_weights_huber(result.residuals);
            
            // Minimi quadrati pesati
            result = weighted_solve(...);
        }
        
        return result;
    }
};
\end{lstlisting}

\textbf{Beneficio}: Riduzione automatica del peso degli outlier.

\section{Supporto Multi-Piattaforma}

\subsection{Build WebAssembly}

\textbf{Obiettivo}: Eseguire AstDyn nel browser web.

\textbf{Casi d'uso}:
\begin{itemize}
    \item Strumenti educativi (calcolatore orbitale interattivo)
    \item Visualizzazione orbita lato client
    \item Nessun server richiesto per calcoli semplici
\end{itemize}

\textbf{Build}:
\begin{lstlisting}[language=bash]
emcc -O3 -s WASM=1 -s ALLOW_MEMORY_GROWTH=1 \
     astdyn.cpp -o astdyn.js
\end{lstlisting}

\subsection{Piattaforme Mobile}

\textbf{Pianificato}: Librerie native iOS e Android.

\textbf{Applicazioni}:
\begin{itemize}
    \item App di pianificazione osservativa
    \item Tracciamento satellitare in tempo reale
    \item App educative di astronomia
\end{itemize}

\section{Roadmap di Sviluppo}

\subsection{Versione 1.1 (Q2 2026)}

Funzionalità prioritarie:
\begin{itemize}
    \item Parallelizzazione OpenMP
    \item Binding Python (pybind11)
    \item Pressione di radiazione solare
    \item Supporto osservazioni radar
\end{itemize}

\subsection{Versione 1.2 (Q4 2026)}

Capacità estese:
\begin{itemize}
    \item Propagazione della covarianza
    \item Incertezza Monte Carlo
    \item Modello di degassamento cometario
    \item Integratore simplettico
\end{itemize}

\subsection{Versione 2.0 (2027)}

Miglioramenti maggiori:
\begin{itemize}
    \item Gestione incontri ravvicinati (regolarizzazione KS)
    \item Correzioni di relatività generale
    \item Accelerazione GPU (CUDA)
    \item Deployment servizio web
\end{itemize}

\section{Contributi della Comunità}

\subsection{Sviluppo Open Source}

AstDyn accoglie i contributi della comunità:

\textbf{Repository GitHub}: \url{https://github.com/user/astdyn}

\textbf{Aree di contribuzione}:
\begin{itemize}
    \item Nuovi integratori (Dormand-Prince, Radau)
    \item Parser aggiuntivi (JPL, SPICE SPK)
    \item Modelli di forza (forze di marea, GR)
    \item Miglioramenti alla documentazione
    \item Test case e validazione
    \item Ottimizzazioni delle prestazioni
\end{itemize}

\textbf{Linee guida}: Vedi CONTRIBUTING.md nel repository.

\subsection{Citazione di AstDyn}

Se utilizzate AstDyn nella ricerca, si prega di citare:

\begin{verbatim}
@software{astdyn2025,
  author = {Bigi, Michele and Contributors},
  title = {AstDyn: Modern C++ Library for Asteroid Orbit Determination},
  year = {2025},
  version = {1.0.0},
  url = {https://github.com/user/astdyn}
}
\end{verbatim}

\section{Direzioni di Ricerca}

\subsection{Algoritmi Innovativi}

Argomenti di ricerca futura:
\begin{enumerate}
    \item \textbf{IOD con deep learning}: Reti neurali per orbita iniziale da 2 osservazioni
    \item \textbf{Filtro di Kalman}: Determinazione orbitale sequenziale
    \item \textbf{Metodi bayesiani}: Soluzioni orbitali probabilistiche
    \item \textbf{Probabilità di collisione}: Monte Carlo veloce per analisi di congiunzione
    \item \textbf{Tracciamento multi-oggetto}: Determinazione orbitale simultanea per più asteroidi
\end{enumerate}

\subsection{Applicazioni Interdisciplinari}

Oltre gli asteroidi:
\begin{itemize}
    \item \textbf{Tracciamento detriti spaziali}: Determinazione orbite LEO/GEO
    \item \textbf{Asteroidi binari}: Dinamica di orbite mutue
    \item \textbf{Lune planetarie}: Determinazione orbite satellitari
    \item \textbf{Transiti esopianetari}: Analisi temporale
\end{itemize}

\section{Riepilogo}

Gli sviluppi pianificati per AstDyn includono:

\begin{enumerate}
    \item \textbf{Fisica}: Forze non gravitazionali, relatività, incontri ravvicinati
    \item \textbf{Algoritmi}: Propagazione incertezze, stima robusta, nuovi integratori
    \item \textbf{Prestazioni}: OpenMP, accelerazione GPU, deployment cloud
    \item \textbf{Interfacce}: Binding Python, servizio web, piattaforme mobile
    \item \textbf{Dati}: Osservazioni radar, astrometria Gaia, pipeline survey
    \item \textbf{Comunità}: Contributi open source, collaborazioni di ricerca
\end{enumerate}

Questi miglioramenti espanderanno le capacità di AstDyn mantenendo i principi di design fondamentali di accuratezza, affidabilità e facilità d'uso.

\vspace{1cm}

\textit{Contributi e suggerimenti sono benvenuti. Visita il repository GitHub per partecipare allo sviluppo di AstDyn.}
