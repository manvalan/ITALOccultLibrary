\chapter{Numerical Integration Methods}
\label{ch:numerical_integration}

\section{Introduction}

Orbital motion under perturbations requires solving differential equations that generally have no closed-form solution. This chapter presents the numerical integration methods implemented in AstDyn for accurate and efficient orbit propagation.

\subsection{The Initial Value Problem}

We seek to solve the system of ordinary differential equations (ODEs):
\begin{equation}
    \dot{\mathbf{y}} = \mathbf{f}(t, \mathbf{y}), \quad \mathbf{y}(t_0) = \mathbf{y}_0
\end{equation}

where $\mathbf{y} = [\mathbf{r}, \mathbf{v}]^T \in \mathbb{R}^6$ is the state vector (position and velocity), and $\mathbf{f}$ represents the equations of motion including all perturbations.

The goal is to advance from initial state $(t_0, \mathbf{y}_0)$ to final state $(t_f, \mathbf{y}_f)$ with controlled error.

\subsection{Classification of Integration Methods}

Numerical integrators can be classified along several axes:

\begin{itemize}
    \item \textbf{Explicit vs Implicit}: Whether $\mathbf{y}_{n+1}$ appears on both sides of the update equation
    \item \textbf{Single-step vs Multi-step}: Whether only the current state or multiple previous states are used
    \item \textbf{Fixed vs Adaptive}: Whether step size is constant or varies based on error estimates
    \item \textbf{Symplectic vs Non-symplectic}: Whether the method preserves the symplectic structure of Hamiltonian systems
\end{itemize}

\section{Runge-Kutta Methods}

Runge-Kutta (RK) methods are single-step, explicit integrators that achieve high order by evaluating the derivative function at multiple intermediate points within each step.

\subsection{Classical Fourth-Order Runge-Kutta (RK4)}

\subsubsection{Algorithm}

The RK4 method computes:

\begin{algorithm}[H]
\caption{RK4 Integration Step}
\begin{algorithmic}[1]
\REQUIRE $\mathbf{y}_n$, $t_n$, $h$ (step size)
\STATE $\mathbf{k}_1 \gets \mathbf{f}(t_n, \mathbf{y}_n)$
\STATE $\mathbf{k}_2 \gets \mathbf{f}(t_n + h/2, \mathbf{y}_n + h\mathbf{k}_1/2)$
\STATE $\mathbf{k}_3 \gets \mathbf{f}(t_n + h/2, \mathbf{y}_n + h\mathbf{k}_2/2)$
\STATE $\mathbf{k}_4 \gets \mathbf{f}(t_n + h, \mathbf{y}_n + h\mathbf{k}_3)$
\STATE $\mathbf{y}_{n+1} \gets \mathbf{y}_n + \frac{h}{6}(\mathbf{k}_1 + 2\mathbf{k}_2 + 2\mathbf{k}_3 + \mathbf{k}_4)$
\RETURN $\mathbf{y}_{n+1}$
\end{algorithmic}
\end{algorithm}

\subsubsection{Properties}

\begin{itemize}
    \item \textbf{Order}: 4 (local truncation error $\propto h^5$)
    \item \textbf{Function evaluations}: 4 per step
    \item \textbf{Stability}: Good for non-stiff problems
    \item \textbf{Error control}: None (fixed step size)
\end{itemize}

\subsubsection{Advantages and Limitations}

\textbf{Advantages}:
\begin{itemize}
    \item Simple to implement
    \item Self-starting (no initialization required)
    \item Moderate accuracy for most problems
    \item Predictable computational cost
\end{itemize}

\textbf{Limitations}:
\begin{itemize}
    \item No automatic error control
    \item Step size must be chosen manually
    \item Not optimal for high-precision work
    \item Can be inefficient (too small steps) or inaccurate (too large steps)
\end{itemize}

\subsection{Runge-Kutta-Fehlberg 7(8) - RKF78}

RKF78 is an \textit{embedded} Runge-Kutta method that provides both a 7th-order and an 8th-order solution, enabling automatic step size control.

\subsubsection{Algorithm}

\begin{algorithm}[H]
\caption{RKF78 Adaptive Step}
\begin{algorithmic}[1]
\REQUIRE $\mathbf{y}_n$, $t_n$, $h$ (current step size), $\epsilon_{\text{tol}}$ (tolerance)
\STATE Compute 13 stage derivatives $\mathbf{k}_1, \ldots, \mathbf{k}_{13}$ using Butcher tableau
\STATE $\mathbf{y}_7 \gets \mathbf{y}_n + h\sum_{i=1}^{13} b_i^{(7)} \mathbf{k}_i$ \COMMENT{7th-order solution}
\STATE $\mathbf{y}_8 \gets \mathbf{y}_n + h\sum_{i=1}^{13} b_i^{(8)} \mathbf{k}_i$ \COMMENT{8th-order solution}
\STATE $\epsilon \gets \|\mathbf{y}_8 - \mathbf{y}_7\|$ \COMMENT{Error estimate}
\STATE $\epsilon_{\text{rel}} \gets \epsilon / (\max(\|\mathbf{y}_n\|, \|\mathbf{y}_8\|) + 10^{-10})$
\IF{$\epsilon_{\text{rel}} \leq \epsilon_{\text{tol}}$}
    \STATE Accept step: $\mathbf{y}_{n+1} \gets \mathbf{y}_8$
    \STATE $h_{\text{new}} \gets 0.9 h (\epsilon_{\text{tol}}/\epsilon_{\text{rel}})^{1/8}$
\ELSE
    \STATE Reject step
    \STATE $h_{\text{new}} \gets 0.9 h (\epsilon_{\text{tol}}/\epsilon_{\text{rel}})^{1/8}$
    \STATE Retry with $h \gets h_{\text{new}}$
\ENDIF
\RETURN $\mathbf{y}_{n+1}$, $h_{\text{new}}$
\end{algorithmic}
\end{algorithm}

\subsubsection{Butcher Tableau}

The RKF78 method uses a 13-stage Butcher tableau with carefully chosen coefficients. The full tableau is given in Fehlberg (1968).

\subsubsection{Properties}

\begin{itemize}
    \item \textbf{Order}: 7 (with 8th-order error estimate)
    \item \textbf{Function evaluations}: 13 per accepted step
    \item \textbf{Stability}: Excellent for smooth, non-stiff problems
    \item \textbf{Error control}: Automatic via embedded formula
\end{itemize}

\subsubsection{Step Size Control}

The step size is adjusted using:
\begin{equation}
    h_{\text{new}} = h_{\text{old}} \times \text{safety} \times \left(\frac{\epsilon_{\text{tol}}}{\epsilon_{\text{rel}}}\right)^{1/(q+1)}
\end{equation}

where $q = 7$ is the order and safety factor $\approx 0.9$ prevents oscillations.

Additional constraints:
\begin{itemize}
    \item $h_{\text{min}} \leq h_{\text{new}} \leq h_{\text{max}}$ (bounds)
    \item $0.2 \leq h_{\text{new}}/h_{\text{old}} \leq 6.0$ (rate limiting)
\end{itemize}

\subsubsection{Advantages and Limitations}

\textbf{Advantages}:
\begin{itemize}
    \item High accuracy (7th order)
    \item Automatic step size control
    \item Efficient for smooth problems
    \item Well-suited for asteroid orbit propagation
    \item Default choice in AstDyn
\end{itemize}

\textbf{Limitations}:
\begin{itemize}
    \item 13 function evaluations per step (expensive for complex force models)
    \item Not optimal for stiff problems
    \item Can take very small steps near close approaches
\end{itemize}

\section{Implicit Runge-Kutta Methods}

Implicit methods solve a system of nonlinear equations at each step, providing superior stability for stiff problems.

\subsection{Radau IIA (15th Order) - Radau15}

Radau IIA methods are implicit Runge-Kutta methods with excellent stability properties, particularly suited for stiff differential equations.

\subsubsection{Algorithm}

\begin{algorithm}[H]
\caption{Radau15 Integration Step}
\begin{algorithmic}[1]
\REQUIRE $\mathbf{y}_n$, $t_n$, $h$, $\mathbf{J}$ (Jacobian), $\epsilon_{\text{tol}}$
\STATE Initialize stage derivatives $\mathbf{k}_1, \ldots, \mathbf{k}_8$ (8 stages)
\FOR{Newton iteration $\ell = 1, \ldots, \ell_{\max}$}
    \FOR{stage $i = 1, \ldots, 8$}
        \STATE $\mathbf{y}_i \gets \mathbf{y}_n + h\sum_{j=1}^{8} a_{ij} \mathbf{k}_j$ \COMMENT{Stage value}
        \STATE $\mathbf{r}_i \gets \mathbf{k}_i - \mathbf{f}(t_n + c_i h, \mathbf{y}_i)$ \COMMENT{Residual}
        \STATE Solve $(\mathbf{I} - h a_{ii} \mathbf{J}) \Delta\mathbf{k}_i = \mathbf{r}_i$ \COMMENT{Newton correction}
        \STATE $\mathbf{k}_i \gets \mathbf{k}_i - \Delta\mathbf{k}_i$
    \ENDFOR
    \IF{$\max_i \|\Delta\mathbf{k}_i\| < \epsilon_{\text{Newton}}$}
        \STATE \textbf{break} \COMMENT{Converged}
    \ENDIF
\ENDFOR
\STATE $\mathbf{y}_{n+1} \gets \mathbf{y}_n + h\sum_{i=1}^{8} b_i \mathbf{k}_i$ \COMMENT{Solution}
\STATE $\mathbf{y}_{\text{err}} \gets h\sum_{i=1}^{8} (b_i - \hat{b}_i) \mathbf{k}_i$ \COMMENT{Error estimate}
\RETURN $\mathbf{y}_{n+1}$, $\|\mathbf{y}_{\text{err}}\|$
\end{algorithmic}
\end{algorithm}

\subsubsection{Radau Quadrature Points}

The 8 stages use Radau quadrature points $c_i \in [0,1]$:
\begin{equation}
c = [0, 0.0563, 0.1802, 0.3526, 0.5472, 0.7342, 0.8853, 0.9775]
\end{equation}

These points are roots of specific orthogonal polynomials, chosen to maximize accuracy.

\subsubsection{Properties}

\begin{itemize}
    \item \textbf{Order}: 15
    \item \textbf{Stages}: 8 (implicit)
    \item \textbf{Stability}: A-stable (excellent for stiff problems)
    \item \textbf{Function evaluations}: $\approx 8 \times \ell_{\text{Newton}}$ per step
\end{itemize}

\subsubsection{Optimizations in AstDyn}

To improve performance, AstDyn implements:

\begin{enumerate}
    \item \textbf{LU Decomposition Caching}: Precompute and cache $(\mathbf{I} - h a_{ii} \mathbf{J})^{-1}$ for all stages
    \item \textbf{Reduced Newton Iterations}: Limit to 4 iterations (sufficient for most cases)
    \item \textbf{Numerical Jacobian}: Compute $\mathbf{J}$ via finite differences when analytical form unavailable
    \item \textbf{Relaxed Convergence}: Accept if $\|\Delta\mathbf{k}\| < 0.1 \epsilon_{\text{tol}}$
\end{enumerate}

These optimizations provide $\approx 6\times$ speedup compared to naive implementation.

\subsubsection{Advantages and Limitations}

\textbf{Advantages}:
\begin{itemize}
    \item Highest accuracy (15th order)
    \item A-stable (handles stiff problems)
    \item Large steps possible
    \item Excellent for orbit determination (fitting observations)
\end{itemize}

\textbf{Limitations}:
\begin{itemize}
    \item Computationally expensive (Newton iterations)
    \item Requires Jacobian (computed numerically if needed)
    \item Slower than explicit methods for non-stiff problems
    \item Overkill for simple 2-body propagation
\end{itemize}

\section{Symplectic Integrators}

Symplectic integrators preserve the geometric structure of Hamiltonian systems, ensuring long-term stability and energy conservation.

\subsection{Gauss-Legendre (8th Order) - Gauss}

Gauss-Legendre methods are implicit, symplectic Runge-Kutta methods ideal for conservative systems and long-term integrations.

\subsubsection{Algorithm}

\begin{algorithm}[H]
\caption{Gauss-Legendre Integration Step}
\begin{algorithmic}[1]
\REQUIRE $\mathbf{y}_n$, $t_n$, $h$, $E_0$ (initial energy)
\STATE Initialize $\mathbf{k}_1, \ldots, \mathbf{k}_4$ (4 stages)
\FOR{Fixed-point iteration $\ell = 1, \ldots, \ell_{\max}$}
    \FOR{stage $i = 1, \ldots, 4$}
        \STATE $\mathbf{y}_i \gets \mathbf{y}_n + h\sum_{j=1}^{4} a_{ij} \mathbf{k}_j$
        \STATE $\mathbf{k}_i^{\text{new}} \gets \mathbf{f}(t_n + c_i h, \mathbf{y}_i)$
    \ENDFOR
    \IF{$\max_i \|\mathbf{k}_i^{\text{new}} - \mathbf{k}_i\| < \epsilon_{\text{tol}}$}
        \STATE \textbf{break}
    \ENDIF
    \STATE $\mathbf{k} \gets \mathbf{k}^{\text{new}}$
\ENDFOR
\STATE $\mathbf{y}_{n+1} \gets \mathbf{y}_n + h\sum_{i=1}^{4} b_i \mathbf{k}_i$
\STATE $E_{n+1} \gets$ energy$(\mathbf{y}_{n+1})$ \COMMENT{Monitor energy drift}
\STATE $\Delta E \gets |E_{n+1} - E_0| / |E_0|$
\IF{$\Delta E > 10\epsilon_{\text{tol}}$}
    \STATE Reduce $h$ and retry
\ENDIF
\RETURN $\mathbf{y}_{n+1}$
\end{algorithmic}
\end{algorithm}

\subsubsection{Gauss-Legendre Quadrature Points}

The 4 stages use Gauss-Legendre points:
\begin{align}
c_1 &= \frac{1}{2} - \frac{\sqrt{525 + 70\sqrt{30}}}{70} \approx 0.0694 \\
c_2 &= \frac{1}{2} - \frac{\sqrt{525 - 70\sqrt{30}}}{70} \approx 0.3300 \\
c_3 &= \frac{1}{2} + \frac{\sqrt{525 - 70\sqrt{30}}}{70} \approx 0.6700 \\
c_4 &= \frac{1}{2} + \frac{\sqrt{525 + 70\sqrt{30}}}{70} \approx 0.9306
\end{align}

\subsubsection{Symplectic Property}

For Hamiltonian systems $H(\mathbf{q}, \mathbf{p})$, Gauss-Legendre methods satisfy:
\begin{equation}
    \mathbf{J}^T \mathbf{M} \mathbf{J} = \mathbf{M}
\end{equation}

where $\mathbf{J}$ is the Jacobian of the map $(\mathbf{q}_n, \mathbf{p}_n) \mapsto (\mathbf{q}_{n+1}, \mathbf{p}_{n+1})$ and $\mathbf{M}$ is the symplectic matrix.

This ensures:
\begin{itemize}
    \item Energy oscillates around true value (no secular drift)
    \item Phase space volume preserved
    \item Long-term stability guaranteed
\end{itemize}

\subsubsection{Properties}

\begin{itemize}
    \item \textbf{Order}: 8 (for 4 stages)
    \item \textbf{Symplectic}: Yes
    \item \textbf{Energy conservation}: Excellent ($\Delta E/E < 10^{-15}$ over millennia)
    \item \textbf{Function evaluations}: $\approx 4 \times \ell_{\text{iter}}$ per step
\end{itemize}

\subsubsection{Optimizations for Long-Term Propagation}

AstDyn's Gauss integrator includes:

\begin{enumerate}
    \item \textbf{Adaptive Step Size}: Based on energy drift rather than local error
    \item \textbf{Energy Monitoring}: Continuously track $\Delta E$ to detect numerical issues
    \item \textbf{Reduced Iterations}: 3-5 fixed-point iterations (sufficient for symplectic property)
    \item \textbf{Step Increase}: Automatically increase $h$ when energy well-conserved
\end{enumerate}

\subsubsection{Advantages and Limitations}

\textbf{Advantages}:
\begin{itemize}
    \item Perfect for long-term propagation (> 100 days)
    \item Symplectic (conserves energy)
    \item No secular drift
    \item Ideal for Hamiltonian systems
    \item Competitive speed with adaptive step size
\end{itemize}

\textbf{Limitations}:
\begin{itemize}
    \item Implicit (requires iterations)
    \item Not optimal for short-term, high-precision work
    \item Requires Hamiltonian structure for full benefits
\end{itemize}

\section{Comparison and Selection Guide}

\subsection{Performance Comparison}

Table~\ref{tab:integrator_comparison} summarizes the characteristics of all integrators in AstDyn.

\begin{table}[htbp]
\centering
\begin{tabular}{lcccccc}
\toprule
\textbf{Method} & \textbf{Order} & \textbf{Type} & \textbf{Evals/step} & \textbf{Speed} & \textbf{Accuracy} & \textbf{Best For} \\
\midrule
RK4 & 4 & Explicit & 4 & ★★★★★ & ★★★ & Testing, debug \\
RKF78 & 7(8) & Explicit & 13 & ★★★★ & ★★★★★ & General purpose \\
Radau15 & 15 & Implicit & $\sim$32 & ★★★ & ★★★★★ & Stiff, high precision \\
Gauss & 8 & Symplectic & $\sim$16 & ★★★★ & ★★★★ & Long-term \\
\bottomrule
\end{tabular}
\caption{Comparison of numerical integrators in AstDyn.}
\label{tab:integrator_comparison}
\end{table}

\subsection{Selection Criteria}

\subsubsection{By Application}

\begin{itemize}
    \item \textbf{Occultation Prediction (< 30 days)}: RKF78
    \item \textbf{Orbit Determination (fitting observations)}: Radau15
    \item \textbf{Ephemeris Generation (1 year)}: RKF78 or Gauss
    \item \textbf{Long-term Evolution (> 100 days)}: Gauss
    \item \textbf{Real-time Applications}: RK4 (fixed step)
\end{itemize}

\subsubsection{By Problem Characteristics}

\begin{itemize}
    \item \textbf{Smooth, non-stiff}: RKF78
    \item \textbf{Stiff (close approaches)}: Radau15
    \item \textbf{Hamiltonian (conservative)}: Gauss
    \item \textbf{High precision required}: Radau15
    \item \textbf{Speed critical}: RKF78 or RK4
\end{itemize}

\subsection{Benchmark Results}

Figure~\ref{fig:integrator_benchmark} shows performance for asteroid 17030 Sierks:

\begin{table}[htbp]
\centering
\begin{tabular}{lcccc}
\toprule
\textbf{Test} & \textbf{RK4} & \textbf{RKF78} & \textbf{Radau15} & \textbf{Gauss} \\
\midrule
10 days & 0.03 ms & 0.004 ms & 2 ms & 0.5 ms \\
100 days & 0.3 ms & 0.04 ms & 15 ms & 3 ms \\
365 days & 1.1 ms & 0.15 ms & 50 ms & 8 ms \\
1000 days & 3.0 ms & 0.40 ms & 140 ms & 18 ms \\
\midrule
Energy drift & $10^{-10}$ & $10^{-13}$ & $10^{-14}$ & $10^{-15}$ \\
\bottomrule
\end{tabular}
\caption{CPU time and energy conservation for different integrators.}
\label{tab:benchmark_results}
\end{table}

\section{Implementation in AstDyn}

\subsection{Common Interface}

All integrators inherit from \texttt{Integrator} base class:

\begin{lstlisting}[language=C++,caption={Integrator interface}]
class Integrator {
public:
    virtual Eigen::VectorXd integrate(
        const DerivativeFunction& f,
        const Eigen::VectorXd& y0,
        double t0,
        double tf
    ) = 0;
    
    const IntegrationStatistics& statistics() const;
};
\end{lstlisting}

\subsection{Usage Examples}

\subsubsection{RKF78 (Default)}

\begin{lstlisting}[language=C++]
#include "astdyn/propagation/Integrator.hpp"

RKF78Integrator rkf78(
    0.1,      // initial step [days]
    1e-12,    // tolerance [AU]
    1e-6,     // min step
    100.0     // max step
);

auto y_final = rkf78.integrate(derivative, y0, t0, tf);
\end{lstlisting}

\subsubsection{Radau15 (High Precision)}

\begin{lstlisting}[language=C++]
#include "astdyn/propagation/RadauIntegrator.hpp"

RadauIntegrator radau(
    1.0,      // initial step
    1e-13,    // tolerance (tighter)
    1e-8,     // min step
    10.0,     // max step
    4         // max Newton iterations
);

auto y_final = radau.integrate(derivative, y0, t0, tf);
\end{lstlisting}

\subsubsection{Gauss (Long-term)}

\begin{lstlisting}[language=C++]
#include "astdyn/propagation/GaussIntegrator.hpp"

GaussIntegrator gauss(
    1.0,      // step size [days]
    1e-12,    // tolerance
    0.1,      // min step
    10.0,     // max step
    5         // max iterations
);

// Propagate 1000 days
auto y_final = gauss.integrate(derivative, y0, t0, t0 + 1000.0);

// Energy conserved to machine precision!
\end{lstlisting}

\section{Summary}

Key points about numerical integration in AstDyn:

\begin{enumerate}
    \item \textbf{Four integrators} available: RK4, RKF78, Radau15, Gauss
    \item \textbf{RKF78} is the default choice for most applications
    \item \textbf{Radau15} provides highest accuracy for stiff problems
    \item \textbf{Gauss} is ideal for long-term, energy-conserving propagation
    \item \textbf{Adaptive step size} automatically balances accuracy and efficiency
    \item \textbf{Common interface} allows easy switching between methods
\end{enumerate}

Understanding these integration methods enables:
\begin{itemize}
    \item Choosing the right tool for each problem
    \item Balancing accuracy, speed, and stability
    \item Achieving reliable long-term propagation
    \item Validating results through method comparison
\end{itemize}
